import numpy as np

# Define the training dataset
training_data = np.array([
    [5.0, 70, 6, 'BL5'],
    [5.5, 65, 5, 'BL5'],
    [6.0, 75, 7, 'BL5'],
    [6.5, 80, 8, 'BL5'],
    [7.0, 85, 9, 'BL5'],
    [7.5, 90, 10, 'BL5'],
    [8.0, 95, 11, 'BL5']
])

# Define the test instance
test_instance = np.array([5.8, 80, 7])

# Define the value of K
K = 3

# Calculate the distances between the test instance and each training instance
distances = np.sqrt(np.sum((training_data[:, :3] - test_instance) ** 2, axis=1))

# Find the indices of the K nearest neighbors
nearest_indices = np.argsort(distances)[:K]

# Assign weights to each neighbor based on their distances
weights = 1 / distances[nearest_indices]

# Count the votes for each class
class_votes = {}
for i, index in enumerate(nearest_indices):
    class_label = training_data[index, 3]
    class_votes[class_label] = class_votes.get(class_label, 0) + weights[i]

# Determine the class with the highest weighted votes
predicted_class = max(class_votes, key=class_votes.get)

# Output the predicted class
print("The predicted class is:", predicted_class)
